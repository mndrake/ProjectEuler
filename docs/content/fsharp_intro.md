
<H1>Introduction to F\#</H1>

This will be an overview of basic F# syntax.

To learn F# you can start by doing:

* the introduction lessons at http://www.tryfsharp.org

Then do some of the following:

* Project Euler problems http://projecteuler.net
* Learn by testing https://github.com/ChrisMarinos/FSharpKoans

Other resources:

* F# reference on MSDN http://msdn.microsoft.com/en-us/library/dd233154.aspx

### Comments


    // this is a comment
    (* this is also a comment *)
    (* this is
        a
            multiple line
                comment *)

###Definitions and Type Inference

Definitions are made using the ```let``` keyword. F# will infer the type based
on the values.


    let a = 4
    let b = 1.5
    let c = "hello"
    
    a,b,c




    val it : int * float * string = (4, 1.5, "hello")



###Math Operators

There are math keywords build into F#.



    // exponential power
    exp(1.0)




    val it : float = 2.718281828




    // raise to a power for floats
    3.0 ** 2.0




    val it : float = 9.0




    // raise to a power for integers
    pown 3 2




    val it : int = 9




    // modulus
    8%3




    val it : int = 2



###Lists

Lists are defined by brackets [ ].  Also common in F# are arrays [| |] and
sequences seq { }.

To define a sequence of numbers you can use ```start .. end``` or if the
increment is other than one use ```start .. increment .. end```.


    [1..10]




    val it : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]




    [10..-1..1]




    val it : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]



###Functions

To create a named function the format is:

```let``` *function_name* *arguments* = *function_body*


    let f x = x + 1
    
    f 4




    val it : int = 5



###Pipeline

The pipeline operator ```|>``` is used to use the value on the left side of the
operator as the input to the function on the right side of the operator. It is
used the chain multiple steps together.


    let addOne x = x + 1
    let timesTwo x = x * 2
    
    3 |> addOne |> timesTwo




    val it : int = 8



###Anonymous Functions

Anonymous functions allow for the creation of "throw away" or "helper"
functions.

The have the syntax of :
```fun``` *arguments* -> *function_body*


    4 |> fun x -> x+1




    val it : int = 5



### FSharp Collections

http://msdn.microsoft.com/en-us/library/ee353413.aspx

The F# collection modules have many useful methods that you will need to get
familiar with. (List, Array, Seq, Array2D, Set, etc.)

The following is just a sample of the methods available.


    // filter - filters any values that the condition is true
    [1 .. 10] |> List.filter (fun n -> n%2=0)




    val it : int list = [2; 4; 6; 8; 10]




    // map - maps a function to each element
    [1 .. 5] |> List.map (fun n -> n*n)




    val it : int list = [1; 4; 9; 16; 25]




    // sum - sums the collection, elements must have an add method
    [1 .. 5] |> List.sum




    val it : int = 15




    // sumBy - applies a function to each member before summing
    [1 .. 5] |> List.sumBy (fun n -> n*n)




    val it : int = 55




    // Seq.unfold - returns a sequence generated by a function
    Seq.unfold (fun (a,b) -> Some(a,(b,b+a))) (1,2)
    |> Seq.take 5 // take first 5 items in sequence
    |> Seq.toList // convert to a list




    val it : int list = [1; 2; 3; 5; 8]




    // infinite sequence of square integers
    Seq.initInfinite (fun i -> i*i)
    |> Seq.takeWhile (fun n -> n<100) // take all less than 100
    |> Seq.sum // sum




    val it : int = 285



###Match

The ```match``` keyword uses pattern matching and can be thought of a case or
switch statement (only more powerful).


    let isEven n =
        match n with
        |x when x%2=0 -> true
        |_ -> false
                   
    isEven 5




    val it : bool = false



### Recursion

The ```rec``` keyword is used to indicate that a function can be called
recursively.


    let rec factorial_v1 n = 
        match n with
        |0|1 -> 1I
        |n -> bigint n * factorial_v1(n-1)
        
    List.init 5 factorial_v1




    val it : Numerics.BigInteger list = [1; 1; 2; 6; 24]




    // tail recursive version (generally preferred versus prior version)
    let factorial_v2 n =
        let rec loop x acc =
            match x with
            |0|1 -> acc * 1I
            |n -> loop (x-1) (bigint n*acc)
        loop n 1I
        
    List.init 5 factorial_v2




    val it : Numerics.BigInteger list = [1; 1; 2; 6; 24]




    
